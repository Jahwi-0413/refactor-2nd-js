# 3. 코드에서 나는 악취

리팩토링을 언제 적용해야되는지에 대한 보다 정확한 기준을 표현하기 위해 '냄새' 라는 표현을 쓰게 되었다.
3장에서는 리팩터링이 핖요한 징후를 살펴보고 각 항목을 해결하기 위한 기법들은 6~12장에서 소개된다.

## 3.1 기이한 이름

함수나 변수, 클래스 등은 그 이름만 보고도 어떤 역할을 하는지 감이 와야한다.
만약 그렇지 않다면 리팩터링이 필요하다는 뜻이다. 또한 리팩터링 시 어떠한 이름으로 해야할지 애매하다면 설계가 잘못되었을 확률이 높다.
애매한 이름들을 정리하다 보면 코드가 간결해지는 경우가 많다.

## 3.2 중복 코드

중복되는 로직의 코드는 하나로 통합할 수 있다.

## 3.3 긴 함수

옛날에는 함수가 길수록 이해하기 어려운걸 알긴 했지만 서브루틴을 호출하는 비용이 커서 짧은 함수를 꺼렸다.
하지만 최근의 언어들은 함수를 호출하는 비용이 거의 없기 때문에 적극적으로 함수 쪼개야한다.

추출하기 좋은 코드 중 하나는 주석이 있는 코드이다.
코드만으로는 내용을 설명하기 힘들 떄 주석을 달아놓는데, 함수로 추출하면 함수 이름으로 어떤 기능인지 알 수 있기 때문이다.

거대한 switch 문의 각 case를 함수로 추출하는것도 좋은 방법이고, 같은 조건을 기준으로 나뉘는 switch문이 여러개라면 '조건부 로직을 다형성으로 바꾸기'를 적용한다.

## 3.4 긴 매개변수 목록

매개변수가 늘어나면 그 자체로 이해하기 힘들어질 수 있다.
매개변수에서 값을 얻어올 경우에는 매개변수를 '질의 함수'로 바꾸기로 제거한다.
항상 함께 전달되는 매개변수는 '매개변수 객체 만들기'로 묶는다.
함수의 동작 방식을 정하는 플래그 역할의 매개변수는 '플래그 인수 제거하기'로 없애준다.

## 3.5 전역 데이터

전역 데이터는 가장 지도한 악취 중 하나이다.
전역 데이터의 가장 큰 문제는 어느 부분에서 누가 바꿨는지 추적하는게 힘들다는게 문제다.
전역 데이터의 문제는 클래스 변수나 싱글톤에서도 발생하는 문제이다.

전역 데이터는 '변수 캡슐화하기'를 적용해 적어도 어느 부분에서 값을 바꿨는지 추적할 수 있도록 처리하는게 좋다.

## 3.6 가변 데이터

데이터를 변경한 후 예상치 못한 곳에서 문제가 생기는 경우가 많다.
그래서 함수형 프로그래밍에서는 함수에서 값의 복사본을 만들어서 반환하는 것을 기본으로 한다.

무분별한 값의 수정을 줄이기 위해서 변수 캡슐화하기를 적용해 정해진 함수를 거쳐야만 값을 수정할 수 있도록 하는게 좋다.
하나의 변수에 여러 상태를 나타내는 값을 저장하게 한다면 변수 쪼개기를 적용해 용도별 독립 변수에 저장하게 해 값 갱신의 문제가 발생하지 않도록 예방한다.
갱신 로직은 다른 로직과 떨어뜨려 놓는게 좋다.

## 3.7 뒤엉킨 변경

코드를 수정할 때 여러곳을 고쳐야 한다면 뒤엉킨 변경 또는 산탄총 수술 중 하나가 문제라는 것이다.

뒤엉킨 변경은 단일 책임 원칙(SRP - Single Responsibility Principle)이 제대로 지켜지지 않을 때 나타난다.

전체 처리 과정에서 각 다른 맥락의 함수를 호출한다면 관련된 함수를 하나의 모듈로 모아서 맥락별로 구분할 수 있다.

## 3.8 산탄총 수술

코드를 변경할 때 마다 자잘하게 수정해야 할 클래스가 많을때 풍긴다.

변경 부분이 코드에 퍼져있다만 '함수 옮기기', '필드 옮기기'로 한 모듈에 묶는다.
