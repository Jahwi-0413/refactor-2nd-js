# 3. 코드에서 나는 악취

리팩토링을 언제 적용해야되는지에 대한 보다 정확한 기준을 표현하기 위해 '냄새' 라는 표현을 쓰게 되었다.
3장에서는 리팩터링이 핖요한 징후를 살펴보고 각 항목을 해결하기 위한 기법들은 6~12장에서 소개된다.

## 3.1 기이한 이름

함수나 변수, 클래스 등은 그 이름만 보고도 어떤 역할을 하는지 감이 와야한다.
만약 그렇지 않다면 리팩터링이 필요하다는 뜻이다. 또한 리팩터링 시 어떠한 이름으로 해야할지 애매하다면 설계가 잘못되었을 확률이 높다.
애매한 이름들을 정리하다 보면 코드가 간결해지는 경우가 많다.

## 3.2 중복 코드

중복되는 로직의 코드는 하나로 통합할 수 있다.

## 3.3 긴 함수

옛날에는 함수가 길수록 이해하기 어려운걸 알긴 했지만 서브루틴을 호출하는 비용이 커서 짧은 함수를 꺼렸다.
하지만 최근의 언어들은 함수를 호출하는 비용이 거의 없기 때문에 적극적으로 함수 쪼개야한다.

추출하기 좋은 코드 중 하나는 주석이 있는 코드이다.
코드만으로는 내용을 설명하기 힘들 떄 주석을 달아놓는데, 함수로 추출하면 함수 이름으로 어떤 기능인지 알 수 있기 때문이다.

거대한 switch 문의 각 case를 함수로 추출하는것도 좋은 방법이고, 같은 조건을 기준으로 나뉘는 switch문이 여러개라면 '조건부 로직을 다형성으로 바꾸기'를 적용한다.

## 3.4 긴 매개변수 목록

매개변수가 늘어나면 그 자체로 이해하기 힘들어질 수 있다.
매개변수에서 값을 얻어올 경우에는 매개변수를 '질의 함수'로 바꾸기로 제거한다.
항상 함께 전달되는 매개변수는 '매개변수 객체 만들기'로 묶는다.
함수의 동작 방식을 정하는 플래그 역할의 매개변수는 '플래그 인수 제거하기'로 없애준다.

## 3.5 전역 데이터

전역 데이터는 가장 지도한 악취 중 하나이다.
전역 데이터의 가장 큰 문제는 어느 부분에서 누가 바꿨는지 추적하는게 힘들다는게 문제다.
전역 데이터의 문제는 클래스 변수나 싱글톤에서도 발생하는 문제이다.

전역 데이터는 '변수 캡슐화하기'를 적용해 적어도 어느 부분에서 값을 바꿨는지 추적할 수 있도록 처리하는게 좋다.

## 3.6 가변 데이터

데이터를 변경한 후 예상치 못한 곳에서 문제가 생기는 경우가 많다.
그래서 함수형 프로그래밍에서는 함수에서 값의 복사본을 만들어서 반환하는 것을 기본으로 한다.

무분별한 값의 수정을 줄이기 위해서 변수 캡슐화하기를 적용해 정해진 함수를 거쳐야만 값을 수정할 수 있도록 하는게 좋다.
하나의 변수에 여러 상태를 나타내는 값을 저장하게 한다면 변수 쪼개기를 적용해 용도별 독립 변수에 저장하게 해 값 갱신의 문제가 발생하지 않도록 예방한다.
갱신 로직은 다른 로직과 떨어뜨려 놓는게 좋다.

## 3.7 뒤엉킨 변경

코드를 수정할 때 여러곳을 고쳐야 한다면 뒤엉킨 변경 또는 산탄총 수술 중 하나가 문제라는 것이다.

뒤엉킨 변경은 단일 책임 원칙(SRP - Single Responsibility Principle)이 제대로 지켜지지 않을 때 나타난다.

전체 처리 과정에서 각 다른 맥락의 함수를 호출한다면 관련된 함수를 하나의 모듈로 모아서 맥락별로 구분할 수 있다.

## 3.8 산탄총 수술

코드를 변경할 때 마다 자잘하게 수정해야 할 클래스가 많을때 풍긴다.

변경 부분이 코드에 퍼져있다만 '함수 옮기기', '필드 옮기기'로 한 모듈에 묶는다.

## 3.9 기능 편애

프로그램을 모듈화 할 때는 모듈 안에서 상호작용은 많아지도록, 영역 사이의 상호작용은 적어지도록 한다.
기능 편애는 어떤 함수가 자기가 속한 모듈 내에서 보다 외부와 상호작용이 많아질 때 풍기는 냄새다.
이럴떄는 해당 함수를 가까이 있고 싶어 하는 데이터가 있는 곳으로 옮겨주면 된다.

디자인 패턴 중 전략 패턴과 방문자 패턴도 함께 변경하는 것들을 모아놓는 패턴으로 기능 편애를 해결하기 위한 패턴들이다.

## 3.10 데이터 뭉치

데이터는 같이 뭉쳐다니는것을 좋아한다. 그럴때는 데이터를 뭉치는 보금자리를 따로 마련해주는 것이 좋다.

필드 형태의 데이터 뭉치는 "클래스 추출하기"로 하나의 객체로 묶는다.
매개변수 수를 줄일때는 "매개변수 객체 만들기"나 "객체 통체로 넘기기"를 적용해서 매개변수 수를 줄인다.

## 3.11 기본형 집착

프로그래머들은 화표, 좌표 같은 값들도 숫자, 문자열과 같은 기본형을 이용해 표현하는 경우가 많다.
이 냄새는 문자열을 다루는 코드에서 흔하다. 전화번호 같은 경우에는 적어도 일관적으로 형식을 출력해주는 기능이라도 있어야 한다.

"기본형을 객체로 바꾸기"만 적용하자. 자주 함께 몰려다니는 그룹도 데이터 뭉치다. "클래스 추출하기"와 "매개변수 객체 만들기"로 냄새를 없애야한다.

## 3.12 반복되는 switch문

옛날에는 switch문은 모조리 다형성으로 바꾸어야된다고 주장하는 사람들도 있다.
하지만 지금은 그렇지 않으니 반복되는 switch문이나 길게 나열된 if/else문에 집중하여 보자.

중복된 switch문의 문제점은 조건절이 추가될 때 마다 다른 모든 switch문도 찾아서 고쳐야하기 때문이다.

## 3.13 반복문

현재 일급함수를 지원하는 언어가 많아져 "반복문을 파이프라인으로 바꾸기"를 적용해 시대에 걸맞지 않는 반복문을 제거할 수 있다.
filter나 map같은 파이프라인 연산을 사용하면 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 3.14 성의 없는 요소

프로그램 요소 중 함수가 하나밖에 없는 클래스, 본문 코드를 그대로 쓰는거랑 다름없는 함수 같은 요소들은 제거해주는게 좋다.
"함수 인라인하기", "클래스 인라인하기"로 처리한다.
상속의 경우 "계층 합치기"를 적용한다.

## 3.15 추측성 일반화

나중에 사용할 가능성이 있어서 당장 필요 없는 모든 종류의 코드에서 풍기는 냄새다.
당장 걸리적 거리는 코드는 눈앞에서 치워버린다.

테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔하게 볼 수 있다.
"죽은 코드 제거하기"로 없애버리자.

## 3.16 임시 필드

특정 상황에서만 값을 가지는 필드를 가진 클래스들이 존재 할 수도 있다.
하지만 객체를 가져올 때는 모든 필드값이 다 채워져 있을거라 기대하는 경우가 대부분이라 존재 의미를 잘 모르는 필드를 발견하면 고민에 빠지게 될 수도 있다.
이런 경우에는 이러한 필드를 "클래스 추출하기"와 "함수 옮기기"로 임시 필드와 관련된 코드를 모조리 새로운 클래스에 몰아넣는다.
임시 필드의 유효성을 검사하는 경우에는 "특이 케이스 추가"로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거할 수 있다.

## 3.17 메시지 체인

메세지 체인은 한 객체로 다른 객체를 얻어 얻은 객체로부터 다른 객체를 요청하는 방식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드이다.
getter 함수가 꼬리에 꼬리를 물고 이어지거나 임시 변수들이 줄줄이 나엳되는 경우는 클라이언트가 객체 내비게이션에 종속되었음을 의미한다.
이 경우에 내비게이션의 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.
이 문제는 "위임 숨기기"로 해결한다. "함수 추출하기"로 결과 객체를 사용하는 코드 일부를 빼내고 "함수 옮기기"로 체인을 숨길 수 있도록 한다.

## 3.18 중재자

캡슐화 과정에서는 위임이 자주 사용된다.
클래스가 제공하는 메서드 중 대부분이 다른 클래스에 구현을 위임하는 경우에는 "중재자 제거하기"로 직접 작업을 위임하도록 만든다.
위임 메서드 삭제 후 하는 일이 별로 없다면 "함수 인라인하기"를 적용해준다.

## 3.19 내부자 거래

모듈간의 데이터 거래가 많으면 결합도가 높이진다. 모듈간 데이터 거래는 반드시 필요하지만 최소한으로 만들어야 한다.

모듈간에 은밀히? 데이터를 주고받는다면 "함수 옮기기"와 "필드 옮기기"로 은밀한 데이터 거래를 줄인다.
여러 모듈이 같은 관심사를 가지면 공통 부분을 정식으로 처리하는 제 3의 모듈을 만들거나 "위임 숨기기"로 다른 모듈이 중간자 역할을 하도록 만든다.

상속 구조에서는 자식 클래스가 부모 클래스가 공개한 범위 이상으로 접근하려고 한다면 "서브클래스를 위임으로 바꾸기"나 "슈퍼클래스를 위임으로 바꾸기"를 적용한다.

## 3.20 거대한 클래스

한 클래스에 필드나 메서드가 너무 많으면 중복 코드가 늘어나기 좋다.
필드의 경우에는 비슷한 종류(접두어나 접미어가 같은 경우)끼리 "클래스 추출하기"로 뽑아낸다.
메서드의 특정 부분이 반복되면 그 부분을 뽑아서 재활용하는 방식으로 리팩터링 할 수 있다.

## 3.21 서로 다른 인터페이스의 대안 클래스들

클래스의 장점은 언제든 다른 클래스로 교체가 가능한데, 인터페이스가 같을 경우에만 할 수 있다.
인터페이스가 다르다면 "함수 선언 바꾸기"로 일치시키거나 인터페이스가 같아지도록 "함수 옮기기"로 함수를 클래스로 밀어넣을 수 있다.
그러다 대안 클래스들 사이에 중복이 생기면 "슈퍼클래스 추출하기"를 적용할지 고려해본다.

## 3.22 데이터 클래스

데이터 클래스(데이터 필드, 게터, 세터로만 구성)는 다른 클래스가 너무 깊게까지 다루는 경우가 많다.
클래스에 public 필드가 있다면 "레코드 캡슐화하기"로 숨겨준다. 변경하면 안되는 필드는 "세터 제거하기"로 접근할 방법을 없앤다.

다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 메서드를 찾아가 "함수 옮기기"로 데이터 클래스로 옮길 수 있는지 확인한다. 만약 힘들다면 관련 로직만 별도의 메서드로 뽑아낸다.

"단계 쪼개기"로 나온 중간 데이터 구조는 대부분 불변인데, 불변 필드는 굳이 필드화 할 필요 없다. 불변으로 부터 나오는 데이터는 필드 자체를 공개해도 된다.

## 3.23 상속 포기

서브 클래스가 부모의 유산을 물려받고 싶지 않아할 때가 있다.
이런 경우에는 부모 클래스로부터 새로운 서브 클래스를 만들고 물려받지 않을 유산들만 새로운 서브 클래스로 내린다.
그러면 부모 클래스에는 유산 받고 싶은 정보만 남게 된다.

상속 포기 냄새는 서브클래스가 부모의 동작을 필요로하지만 인터페이스는 따르고 싶지 않을 때 심하게 냄새난다.
구현을 따르는 것은 이해할 수 있지만 인터페이스를 따르지 않은것은 상당히 무례한 태도다. (??)
이럴 때는 "서브클래스를 위임으로 바꾸기"나 "슈퍼클래스를 위임으로 바꾸기"로 상속 메커니즘에서 벗어나도록 한다.

## 3.24 주석

주석은 악취가 아닌 향기를 입히지만 가끔 주석을 탈취제로 사용하는 경우가 있다.
주석이 많은 경우에는 코드를 잘못 작성했기 때문일 경우가 많다.

코드 블록이 하는 일에 주석을 남기고 싶다면 "함수 추출하기"를 적용해본다.
이미 추출된 함수에도 설명이 필요하다면 "함수 선언 바꾸기"로 함수 이름을 바꾼다.
시스템이 동작하기 위한 선행조건을 명시하고 싶으면 "어서션 추가하기"를 적용할 수 있다.

| 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
