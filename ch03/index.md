# 3. 코드에서 나는 악취

리팩토링을 언제 적용해야되는지에 대한 보다 정확한 기준을 표현하기 위해 '냄새' 라는 표현을 쓰게 되었다.
3장에서는 리팩터링이 핖요한 징후를 살펴보고 각 항목을 해결하기 위한 기법들은 6~12장에서 소개된다.

## 3.1 기이한 이름

함수나 변수, 클래스 등은 그 이름만 보고도 어떤 역할을 하는지 감이 와야한다.
만약 그렇지 않다면 리팩터링이 필요하다는 뜻이다. 또한 리팩터링 시 어떠한 이름으로 해야할지 애매하다면 설계가 잘못되었을 확률이 높다.
애매한 이름들을 정리하다 보면 코드가 간결해지는 경우가 많다.

## 3.2 중복 코드

중복되는 로직의 코드는 하나로 통합할 수 있다.

## 3.3 긴 함수

옛날에는 함수가 길수록 이해하기 어려운걸 알긴 했지만 서브루틴을 호출하는 비용이 커서 짧은 함수를 꺼렸다.
하지만 최근의 언어들은 함수를 호출하는 비용이 거의 없기 때문에 적극적으로 함수 쪼개야한다.

추출하기 좋은 코드 중 하나는 주석이 있는 코드이다.
코드만으로는 내용을 설명하기 힘들 떄 주석을 달아놓는데, 함수로 추출하면 함수 이름으로 어떤 기능인지 알 수 있기 때문이다.

거대한 switch 문의 각 case를 함수로 추출하는것도 좋은 방법이고, 같은 조건을 기준으로 나뉘는 switch문이 여러개라면 '조건부 로직을 다형성으로 바꾸기'를 적용한다.

## 3.4 긴 매개변수 목록

매개변수가 늘어나면 그 자체로 이해하기 힘들어질 수 있다.
매개변수에서 값을 얻어올 경우에는 매개변수를 '질의 함수'로 바꾸기로 제거한다.
항상 함께 전달되는 매개변수는 '매개변수 객체 만들기'로 묶는다.
함수의 동작 방식을 정하는 플래그 역할의 매개변수는 '플래그 인수 제거하기'로 없애준다.

## 3.5 전역 데이터

전역 데이터는 가장 지도한 악취 중 하나이다.
전역 데이터의 가장 큰 문제는 어느 부분에서 누가 바꿨는지 추적하는게 힘들다는게 문제다.
전역 데이터의 문제는 클래스 변수나 싱글톤에서도 발생하는 문제이다.

전역 데이터는 '변수 캡슐화하기'를 적용해 적어도 어느 부분에서 값을 바꿨는지 추적할 수 있도록 처리하는게 좋다.

## 3.6 가변 데이터

데이터를 변경한 후 예상치 못한 곳에서 문제가 생기는 경우가 많다.
그래서 함수형 프로그래밍에서는 함수에서 값의 복사본을 만들어서 반환하는 것을 기본으로 한다.

무분별한 값의 수정을 줄이기 위해서 변수 캡슐화하기를 적용해 정해진 함수를 거쳐야만 값을 수정할 수 있도록 하는게 좋다.
하나의 변수에 여러 상태를 나타내는 값을 저장하게 한다면 변수 쪼개기를 적용해 용도별 독립 변수에 저장하게 해 값 갱신의 문제가 발생하지 않도록 예방한다.
갱신 로직은 다른 로직과 떨어뜨려 놓는게 좋다.

## 3.7 뒤엉킨 변경

코드를 수정할 때 여러곳을 고쳐야 한다면 뒤엉킨 변경 또는 산탄총 수술 중 하나가 문제라는 것이다.

뒤엉킨 변경은 단일 책임 원칙(SRP - Single Responsibility Principle)이 제대로 지켜지지 않을 때 나타난다.

전체 처리 과정에서 각 다른 맥락의 함수를 호출한다면 관련된 함수를 하나의 모듈로 모아서 맥락별로 구분할 수 있다.

## 3.8 산탄총 수술

코드를 변경할 때 마다 자잘하게 수정해야 할 클래스가 많을때 풍긴다.

변경 부분이 코드에 퍼져있다만 '함수 옮기기', '필드 옮기기'로 한 모듈에 묶는다.

## 3.9 기능 편애

프로그램을 모듈화 할 때는 모듈 안에서 상호작용은 많아지도록, 영역 사이의 상호작용은 적어지도록 한다.
기능 편애는 어떤 함수가 자기가 속한 모듈 내에서 보다 외부와 상호작용이 많아질 때 풍기는 냄새다.
이럴떄는 해당 함수를 가까이 있고 싶어 하는 데이터가 있는 곳으로 옮겨주면 된다.

디자인 패턴 중 전략 패턴과 방문자 패턴도 함께 변경하는 것들을 모아놓는 패턴으로 기능 편애를 해결하기 위한 패턴들이다.

## 3.10 데이터 뭉치

데이터는 같이 뭉쳐다니는것을 좋아한다. 그럴때는 데이터를 뭉치는 보금자리를 따로 마련해주는 것이 좋다.

필드 형태의 데이터 뭉치는 "클래스 추출하기"로 하나의 객체로 묶는다.
매개변수 수를 줄일때는 "매개변수 객체 만들기"나 "객체 통체로 넘기기"를 적용해서 매개변수 수를 줄인다.

## 3.11 기본형 집착

프로그래머들은 화표, 좌표 같은 값들도 숫자, 문자열과 같은 기본형을 이용해 표현하는 경우가 많다.
이 냄새는 문자열을 다루는 코드에서 흔하다. 전화번호 같은 경우에는 적어도 일관적으로 형식을 출력해주는 기능이라도 있어야 한다.

"기본형을 객체로 바꾸기"만 적용하자. 자주 함께 몰려다니는 그룹도 데이터 뭉치다. "클래스 추출하기"와 "매개변수 객체 만들기"로 냄새를 없애야한다.

## 3.12 반복되는 switch문

옛날에는 switch문은 모조리 다형성으로 바꾸어야된다고 주장하는 사람들도 있다.
하지만 지금은 그렇지 않으니 반복되는 switch문이나 길게 나열된 if/else문에 집중하여 보자.

중복된 switch문의 문제점은 조건절이 추가될 때 마다 다른 모든 switch문도 찾아서 고쳐야하기 때문이다.

## 3.13 반복문

현재 일급함수를 지원하는 언어가 많아져 "반복문을 파이프라인으로 바꾸기"를 적용해 시대에 걸맞지 않는 반복문을 제거할 수 있다.
filter나 map같은 파이프라인 연산을 사용하면 각 원소들이 어떻게 처리되는지 쉽게 파악할 수 있다.

## 3.14 성의 없는 요소

프로그램 요소 중 함수가 하나밖에 없는 클래스, 본문 코드를 그대로 쓰는거랑 다름없는 함수 같은 요소들은 제거해주는게 좋다.
"함수 인라인하기", "클래스 인라인하기"로 처리한다.
상속의 경우 "계층 합치기"를 적용한다.

## 3.15 추측성 일반화

나중에 사용할 가능성이 있어서 당장 필요 없는 모든 종류의 코드에서 풍기는 냄새다.
당장 걸리적 거리는 코드는 눈앞에서 치워버린다.

테스트 코드 말고는 사용하는 곳이 없는 함수나 클래스에서 흔하게 볼 수 있다.
"죽은 코드 제거하기"로 없애버리자.
