# 2. 리팩터링 원칙

## 2.1 리팩터링 정의

- 리팩터링 [명사] : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
- 리팩터링(하다) [동사] : 소프트웨어으 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩토링 기법을 적용해 소프트웨어을 재구성한다.

'리팩터링하다가 코드가 깨져서 며칠 고생했다' 이런 말은 리팩토링을 한 게 아니다.
리팩터링을 하는 동안에는 겉보기는 같기 때문에 버그도 똑같이 발생해야 한다.

## 2.2 두 개의 모자

코드를 수정 할 때는 사용하는 두 개의 모자가 있다. 어떤 모자를 썼는지에 따라 작업의 차이를 알아야 한다.

한 개의 모자는 '기능 추가' 모자이다. 기능을 추가할 때는 기능만 추가해야하고 기존의 코드를 수정하지 않아야 한다.
진척도는 테스트를 추가해서 통과하는지로 측정한다.

다른 한 개의 모자는 '리팩터링'이다. 리팩터링 모자를 쓰면 기능 재구성에만 신경을 쓴다. 새로운 테스트를 추가하지도 않는다.
부득이하게 수정해야할 때는 테스트도 손 본다.

## 2.3 리팩터링 하는 이유

- 리팩터링하면 소프트웨어 설계가 좋아진다.
  - 리팩터링하지 않으면 소프트웨어 설계가 썩을 수 있다.
- 리팩터링하면 소프트웨어를 이해하기 좋아진다.
  - 프로그래밍은 원하는 일을 컴퓨터가 수행할 수 있도록 표현하는 것이다.
  - 원하는 작업과 프로그래밍으로 표현된 코드에 차이점이 적을수록 좋다.
- 리팩터링 하면 버그를 쉽게 찾을 수 있다.
  - 프로그램의 구조를 명확히 다듬으면 지나칠 수 없을 정도로 버그가 명확해진다.
- 리팩터링 하면 개발 속도가 높아진다.
  - 리팩토링을 하지 않을수록 기능 추가나 수정에 들이는 시간이 길어지고 코드의 흐름을 읽어내는것이 고대 유적 발굴만큼 힘들어진다.

## 2.4 언제 리팩터링 해야할까?

- 준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기
- 이해를 위한 리팩터링 : 코드를 읽기 쉽게 만들기
- 쓰레기 줍기 리팩터링
  - 코드 작성 중에 비효율적으로 처리하고 있는 일을 발견하거나, 로직이 쓸데없이 복잡한 경우 곧바로 리팩토링 한다.
- 계획된 리팩터링 vs 수시로 하는 리팩터링
  - 리팩터링은 기간을 잡아서 하는게 아니라 수시로 하는 것이다.
  - 리팩터링 커밋과 개발 커밋을 분리해서 하자는 견해도 있는데, 팀마다 다르지만 필자는 동의하지는 않는다.
- 오래 걸리는 리팩터링
  - 대규모로 리팩터링을 실행하거나 라이브러리 의존성을 해결하는 문제 등이 있다.
    이런 경우에도 따로 시간을 내지 않고 단계별로 조금씩 처리하는것을 권장한다.
- 코드 리뷰에 리팩터링 활용하기
  - 코드 리뷰의 장점에는 다른 사람의 아이디어를 옅볼 수 있다는 점이 있다.
  - 코드 리뷰시에 개선점을 논의하고 바로 적용한다.
- 관리자에게 리팩터링에 대해 어떻게 이야기 할지?
  - 비개발자든 개발자든 리팩터링에 회의적인 사람들이 있다. 그리고 리팩터링 기간을 따로 잡으면 더 싫어할 수도 있다.
    일정은 알아서 잘 관리하고 비개발자인 경우 리팩터링에 대해서 언급하지 않는것도 하나의 방법이다.
- 리팩터링 하지 말아야 할 때
  - 하지 말아야 하는 경우는 경험이 조금 쌓여야 판단할 수 있다.
  - 외부 API를 호출하듯 부르는 경우는 따로 리팩터링 하지 않는다.
  - 기능을 새로 작성할 정도인 경우에도 리팩터링 하지 않는다.

## 2.5 리팩터링시 고려할 점

- 새 기능 개발 속도 저하
  - 리팩터링의 궁극적인 목적에는 개발 속도를 높이는 것이다.
- 코드 소유권
  - API나 함수가 다른 팀, 또는 다른 업체에서 관리하는 경우라면 리팩터링이 힘들어질 수 있다.
    그럴 경우에는 함수 본문에서 새로운 함수를 호출하는 방식으로 처리할 수 있지만 인터페이스가 복잡해 질 수 있다.
  - 코드의 소유권을 너무 좁게 설정하면 (예를 들어 한 개발자가 공개 인터페이스를 제공해야 다른 개발자가 해당 영역에 접근할 수 있는 방식) 간단하게 처리 가능한 것도 복잡하게 처리해야될 수 도 있어서 필자는 권장하지 않는다.
  - 적어도 팀 단위로 코드 소유권을 주는 것이 대규모 시스템 개발 시 좋다.
- 브랜치
  - 개인 브랜치에서 작업을 오래 할 수록 마스터 브랜치와 합치는 게 힘들어진다.
  - CI(Continuous Integration)에서 최소 하루에 한 번은 마스터 브랜치와 동기화를 권장하는데, 필요한 조건들이 있다.
    - 마스터 브랜치가 항상 건강하게 유지될것
    - 거대한 기능을 잘게 쪼개는 방법을 알 것
    - 각 기능을 끌 수 있는 기능 토글을 지원해 미완료된 작업이 시스템을 망치지 않도록 할 것
  - CI는 리팩터링과 궁합이 좋다. -> 익스트림 프로그래밍 (XP)
- 테스팅
  - 리팩터링은 문제 발생시 롤백하거나 빠르게 디버깅할 수 있도록 아주 작은 단위로 해야하며, 자가 테스트를 포함하는것이 좋다.
  - CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(CD)의 핵심이다
- 레거시 코드
  - 테스트 코드가 작성되어 있지 않은 레거시 코드를 리팩터링하는 법은 조금씩이라도 개선하려고 노력하는 수 밖에 없다.
- 데이터베이스
  - 진화형 데이터베이스 설계, 데이터베이스 리팩터링 기법은 데이터베이스 리팩터링에 널리 적용된다.

## 2.6 리팩터링, 아키텍쳐, 애그니(YAGNI)

옛날에는 아키텍쳐나 설계는 한 번 정해지면 바꿀 수 없고, 프로그램은 개발 후에는 부패할 일만 남았다고 여겨졌다.
하지만 리팩터링으로 인해 이러한 인식이 바뀌었다.

유연성 메커니즘 : 향후 변경에 유연하게 대처하기 위한 매커니즘.

유연성 매커니즘의 단점은, 매커니즘을 잘못 구현할 수도 있고, 다양한 상황에 대응하기 위한 코드로 로직이 복잡해질 수 있다.
하지만 리팩터링이 있다면 현재의 요구사항에 충실하고, 요구사항이 변경되면 리팩터링을 실행하면 된다.

YAGNI : You aren't going to need it. (필요 없을 거다.)

## 2.7 리팩터링과 소프트웨어 개발 프로세스

XP의 특징 -> 지속적 통합, 자가 테스트, 리팩터링
자가 테스트 + 리팩터링 : TDD (테스트 주도 개발)

## 2.8 리팩터링과 성능

리팩터링은 실제로 성능을 낮추지만 하드웨어는 점점 발전하니까 그렇게 큰 문제가 되지 않는다.
그리고 리팩터링을 하면 성능 튜닝을 하기 더 쉬워진다.

시스템이 느리다면 대부분은 특정 부분에서 시간을 많이 소요한다.
그러니 일단은 리팩터링을 해서 구조를 정리하고 속도를 측정해서 어느 부분이 오래 걸리는지 알아본 후 개선하는게 바람직하다.

리팩터링을 잘 하면 성능 튜닝에 투입할 시간을 벌 수 있고 성능을 더욱 세밀하게 분석할 수 있다.

## 2.10 리팩터링 자동화

C#이나 Java는 리팩터링 자동화 도구가 있다.
좋은 IDE에서 제공하는 자동화 도구일 수록 안정성이 높다.
하지만 자동화 도구를 맹신하지는 않는 것이 좋고 테스트를 거쳐 적용하는것이 좋다.
하지만 자동화 도구는 리팩터링의 좋은 출발점이 될 수 있다.
